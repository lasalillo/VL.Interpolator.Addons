shader ComputeHelpers : ComputeShaderBase
{

    SamplerState LinearSampler
    {
        Filter = MIN_MAG_MIP_LINEAR;
    };

    float4x4 Translate(float4x4 m, float3 translation)
    {
        m._41_42_43 = translation;
        return m;
    }
	
	float4x4 Scale(float4x4 m, float3 scale)
	{
		m._11_22_33 = scale;
        return m;
	}
	
		float4x4 ScaleLength(float4x4 m, float scale)
	{
		m._11 = scale;
        return m;
	}
	
	float4x4 Rotate(float4x4 m, float rotation)
	{
		m._11 =  cos(radians(360*(rotation)));
		m._13 = -sin(radians(360*(rotation)));
		m._31 =  sin(radians(360*(rotation)));
		m._33 =  cos(radians(360*(rotation)));
        return m;
	}


		float3 HUEtoRGB(in float H)
	{
		H=frac(H);
		float R = abs(H * 6 - 3) - 1;
		float G = 2 - abs(H * 6 - 2);
		float B = 2 - abs(H * 6 - 4);
		return saturate(float3(R,G,B));
	}
	
	
		float3 HSLtoRGB(in float3 HSL)
	{
		float3 RGB = HUEtoRGB(HSL.x);
		float C = (1 - abs(2 * HSL.z - 1)) * HSL.y;
		return (RGB - 0.5) * C + HSL.z;
	}


		float Map(float value, float inMin, float inMax, float outMin, float outMax) 
	{
		return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
	}
	

	
    uint CalcLinearDispatchThreadId()
    {
        uint3 ti = streams.DispatchThreadId;
        uint3 gc = streams.ThreadGroupCount;
        
        uint sy = gc.x * streams.ThreadCountX;
        uint sz = sy * gc.y * streams.ThreadCountY;

        return ti.z * sz + ti.y * sy + ti.x;
    }

    int2 TextureSize;
    float2 CalcTexCoord()
    {
        uint3 ti = streams.DispatchThreadId;
        float2 texSize = TextureSize;
        return float2(0.5/texSize.x + ti.x / texSize.x , 0.5/texSize.y + ti.y / texSize.y);
    }  
};